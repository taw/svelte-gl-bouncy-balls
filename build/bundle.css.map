{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../Layer.svelte",
    "../../Overlay.svelte",
    "../../Scene.svelte"
  ],
  "sourcesContent": [
    "<script>\n  import { get_layer, set_layer } from '../internal/index.mjs';\n\n  export let index = undefined;\n\n  set_layer(get_layer().add_child(index));\n</script>\n\n<div class=\"layer\">\n  <slot></slot>\n</div>\n\n<style>\n  /* for overlays, create a stacking context */\n  .layer {\n    position: absolute;\n    top: 0;\n    left: 0;\n  }\n</style>\n",
    "<script>\n  import Point from './Point.svelte';\n\n  export let location;\n  export let direction = undefined;\n  export let snap = false;\n\n  $: px = n => `${snap ? Math.round(n) : n}px`;\n</script>\n\n<Point {location} {direction} let:x let:y let:vector>\n  <span\n    class=\"overlay\"\n    style=\"transform: translate3d({px(x)}, {px(y)}, 0)\"\n  >\n    <slot vector={vector}></slot>\n  </span>\n</Point>\n\n<style>\n  .overlay {\n    position: absolute;\n    left: 0;\n    top: 0;\n    user-select: none;\n    -moz-user-select: none;\n    will-change: transform;\n  }\n</style>\n",
    "<script context=\"module\">\n  import { readable } from 'svelte/store';\n\n  function is_intersecting(el) {\n    // TODO this shouldn't be necessary. But the initial value\n    // of entry.isIntersecting in an IO can be incorrect, it\n    // turns out? need to investigate further\n    const bcr = el.getBoundingClientRect();\n\n    return (\n      bcr.bottom > 0 &&\n      bcr.right  > 0 &&\n      bcr.top    < window.innerHeight &&\n      bcr.left   < window.innerWidth\n    );\n  }\n\n  function get_visibility(node) {\n    return readable(false, set => {\n      if (typeof IntersectionObserver !== 'undefined') {\n        const observer = new IntersectionObserver(entries => {\n          // set(entries[0].isIntersecting);\n          set(is_intersecting(node));\n        });\n\n        observer.observe(node);\n        return () => observer.unobserve(node);\n      }\n\n      if (typeof window !== 'undefined') {\n        function handler() {\n          const { top, bottom } = node.getBoundingClientRect();\n          set(bottom > 0 && top < window.innerHeight);\n        }\n\n        window.addEventListener('scroll', handler);\n        window.addEventListener('resize', handler);\n\n        return () => {\n          window.removeEventListener('scroll', handler);\n          window.removeEventListener('resize', handler);\n        };\n      }\n    });\n  }\n</script>\n\n<script>\n  import { setContext, onMount, onDestroy, tick } from 'svelte';\n  import { writable } from 'svelte/store';\n  import { RENDERER, LAYER, PARENT, CAMERA, create_layer } from '../internal/index.mjs';\n  import { create_worker, process_color } from '../internal/utils.mjs';\n  import * as mat4 from 'gl-matrix/mat4';\n  import * as vec3 from 'gl-matrix/vec3';\n\n  export let background = [1, 1, 1];\n  export let backgroundOpacity = 1;\n  export let fog = undefined;\n  export let pixelRatio = undefined;\n\n  const use_fog = 'fog' in $$props;\n\n  $: bg = process_color(background);\n\n  let canvas;\n  let visible = writable(false);\n  let pending = false;\n  let update_scheduled = false;\n  let w;\n  let h;\n\n  let gl;\n  let draw = () => {};\n  let camera_stores = {\n    camera_matrix: writable(),\n    view: writable(),\n    projection: writable()\n  };\n\n  const invalidate = typeof window !== 'undefined'\n    ? () => {\n      if (!update_scheduled) {\n        update_scheduled = true;\n        requestAnimationFrame(draw);\n      }\n    }\n    : () => {};\n\n  const width = writable(1);\n  const height = writable(1);\n\n  const root_layer = create_layer(0, invalidate);\n\n  const default_camera = { /* TODO */ };\n  let camera = default_camera;\n  const num_lights = 8;\n\n  const meshes = [];\n\n  // lights\n  const lights = {\n    ambient: [],\n    directional: [],\n    point: []\n  };\n\n  function add_to(array) {\n    return fn => {\n      array.push(fn);\n      invalidate();\n\n      onDestroy(() => {\n        const i = array.indexOf(fn);\n        if (~i) array.splice(i, 1);\n        invalidate();\n      });\n    }\n  }\n\n  const targets = new Map();\n  let camera_position_changed_since_last_render = true;\n\n  const scene = {\n    defines: [\n      `#define NUM_LIGHTS 2\\n` + // TODO configure this\n      `#define USE_FOG ${use_fog}\\n`\n    ].join(''),\n\n    add_camera: _camera => {\n      if (camera && camera !== default_camera) {\n        throw new Error(`A scene can only have one camera`);\n      }\n\n      camera = _camera;\n      invalidate();\n\n      // TODO this is garbage\n      camera_stores.camera_matrix.set(camera.matrix);\n      camera_stores.projection.set(camera.projection);\n      camera_stores.view.set(camera.view);\n\n      onDestroy(() => {\n        camera = default_camera;\n        invalidate();\n      });\n    },\n\n    update_camera: camera => {\n      // for overlays\n      camera_stores.camera_matrix.set(camera.matrix);\n      camera_stores.view.set(camera.view);\n      camera_stores.projection.set(camera.projection);\n\n      camera_position_changed_since_last_render = true;\n      invalidate();\n    },\n\n    add_directional_light: add_to(lights.directional),\n    add_point_light: add_to(lights.point),\n    add_ambient_light: add_to(lights.ambient),\n\n    get_target(id) {\n      if (!targets.has(id)) targets.set(id, writable(null))\n      return targets.get(id);\n    },\n\n    invalidate,\n\n    ...camera_stores,\n\n    width,\n    height\n  };\n\n  setContext(RENDERER, scene);\n  setContext(LAYER, root_layer);\n\n  const origin = mat4.identity(mat4.create());\n  const ctm = writable(origin);\n  setContext(PARENT, {\n    get_matrix_world: () => origin,\n    ctm: { subscribe: ctm.subscribe }\n  });\n\n  onMount(() => {\n    scene.canvas = canvas;\n    gl = scene.gl = canvas.getContext('webgl');\n    visible = get_visibility(canvas);\n\n    const extensions = [\n      'OES_element_index_uint',\n      'OES_standard_derivatives'\n    ];\n\n    extensions.forEach(name => {\n      const ext = gl.getExtension(name);\n      if (!ext) {\n        throw new Error(`Unsupported extension: ${name}`);\n      }\n    });\n\n    draw = force => {\n      if (!camera) return; // TODO make this `!ready` or something instead\n\n      if (dimensions_need_update) {\n        const DPR = pixelRatio || window.devicePixelRatio || 1;\n        canvas.width = $width * DPR;\n        canvas.height = $height * DPR;\n        gl.viewport(0, 0, $width * DPR, $height * DPR);\n\n        dimensions_need_update = false;\n      }\n\n      update_scheduled = false;\n\n      if (!$visible && !force) {\n        pending = true;\n        return;\n      };\n\n      pending = false;\n\n      gl.clearColor(...bg, backgroundOpacity);\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n      gl.enable(gl.CULL_FACE);\n      gl.enable(gl.BLEND);\n\n      // calculate total ambient light\n      const ambient_light = lights.ambient.reduce((total, { color, intensity }) => {\n        return [\n          Math.min(total[0] + color[0] * intensity, 1),\n          Math.min(total[1] + color[1] * intensity, 1),\n          Math.min(total[2] + color[2] * intensity, 1)\n        ];\n      }, new Float32Array([0, 0, 0]));\n\n      let previous_program;\n\n      let previous_state = {\n        [gl.DEPTH_TEST]: null,\n        [gl.CULL_FACE]: null\n      };\n\n      const enable = (key, enabled) => {\n        if (previous_state[key] !== enabled) {\n          if (enabled) gl.enable(key);\n          else gl.disable(key);\n\n          previous_state[key] = enabled;\n        }\n      };\n\n      function render_mesh({\n        model,\n        model_inverse_transpose,\n        geometry,\n        material,\n        depthTest,\n        doubleSided\n      }) {\n        // TODO should this even be possible?\n        if (!material) return;\n\n        enable(gl.DEPTH_TEST, depthTest !== false);\n        enable(gl.CULL_FACE, doubleSided !== true);\n\n        gl.blendFuncSeparate(\n          gl.SRC_ALPHA, // source rgb\n          gl.ONE_MINUS_SRC_ALPHA, // dest rgb\n          gl.SRC_ALPHA, // source alpha\n          gl.ONE // dest alpha\n        );\n\n        if (material.program !== previous_program) {\n          previous_program = material.program;\n\n          // TODO move logic to the mesh/material?\n          gl.useProgram(material.program);\n\n          // set built-ins\n          gl.uniform3fv(material.uniform_locations.AMBIENT_LIGHT, ambient_light);\n\n          if (use_fog) {\n            gl.uniform3fv(material.uniform_locations.FOG_COLOR, bg);\n            gl.uniform1f(material.uniform_locations.FOG_DENSITY, fog);\n          }\n\n          if (material.uniform_locations.DIRECTIONAL_LIGHTS) {\n            for (let i = 0; i < num_lights; i += 1) {\n              const light = lights.directional[i];\n              if (!light) break;\n\n              gl.uniform3fv(material.uniform_locations.DIRECTIONAL_LIGHTS[i].direction, light.direction);\n              gl.uniform3fv(material.uniform_locations.DIRECTIONAL_LIGHTS[i].color, light.color);\n              gl.uniform1f(material.uniform_locations.DIRECTIONAL_LIGHTS[i].intensity, light.intensity);\n            }\n          }\n\n          if (material.uniform_locations.POINT_LIGHTS) {\n            for (let i = 0; i < num_lights; i += 1) {\n              const light = lights.point[i];\n              if (!light) break;\n\n              gl.uniform3fv(material.uniform_locations.POINT_LIGHTS[i].location, light.location);\n              gl.uniform3fv(material.uniform_locations.POINT_LIGHTS[i].color, light.color);\n              gl.uniform1f(material.uniform_locations.POINT_LIGHTS[i].intensity, light.intensity);\n            }\n          }\n\n          gl.uniform3fv(material.uniform_locations.CAMERA_WORLD_POSITION, camera.world_position);\n          gl.uniformMatrix4fv(material.uniform_locations.VIEW, false, camera.view);\n          gl.uniformMatrix4fv(material.uniform_locations.PROJECTION, false, camera.projection);\n        }\n\n        // set mesh-specific built-in uniforms\n        gl.uniformMatrix4fv(material.uniform_locations.MODEL, false, model);\n        gl.uniformMatrix4fv(material.uniform_locations.MODEL_INVERSE_TRANSPOSE, false, model_inverse_transpose);\n\n        // set material-specific built-in uniforms\n        material.apply_uniforms(gl);\n\n        // set attributes\n        geometry.set_attributes(gl);\n\n        // draw\n        if (geometry.index) {\n          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometry.buffers.__index);\n          gl.drawElements(gl[geometry.primitive], geometry.index.length, gl.UNSIGNED_INT, 0);\n        } else {\n          const primitiveType = gl[geometry.primitive];\n          gl.drawArrays(primitiveType, 0, geometry.count);\n        }\n      }\n\n      function render_layer(layer) {\n        if (layer.needs_sort) {\n          layer.child_layers.sort((a, b) => a.index - b.index);\n          layer.needs_sort = false;\n        }\n\n        gl.depthMask(true);\n        gl.clearDepth(1.0);\n        gl.clear(gl.DEPTH_BUFFER_BIT);\n\n        for (let i = 0; i < layer.meshes.length; i += 1) {\n          render_mesh(layer.meshes[i]);\n        }\n\n        // TODO sort transparent meshes, furthest to closest\n        gl.depthMask(false);\n\n        if (camera_position_changed_since_last_render || layer.needs_transparency_sort) {\n          sort_transparent_meshes(layer.transparent_meshes);\n          layer.needs_transparency_sort = false;\n        }\n\n        for (let i = 0; i < layer.transparent_meshes.length; i += 1) {\n          render_mesh(layer.transparent_meshes[i]);\n        }\n\n        for (let i = 0; i < layer.child_layers.length; i += 1) {\n          render_layer(layer.child_layers[i]);\n        }\n      }\n\n      render_layer(root_layer);\n      camera_position_changed_since_last_render = false;\n    };\n\n    // for some wacky reason, Adblock Plus seems to prevent the\n    // initial dimensions from being correctly reported\n    const timeout = setTimeout(() => {\n      $width = canvas.clientWidth;\n      $height = canvas.clientHeight;\n    });\n\n    tick().then(() => draw(true));\n\n    return () => {\n      gl.getExtension('WEBGL_lose_context').loseContext();\n      clearTimeout(timeout);\n    };\n  });\n\n  const sort_transparent_meshes = meshes => {\n    if (meshes.length < 2) return;\n\n    const lookup = new Map();\n    const out = new Float32Array(16);\n\n    meshes.forEach(mesh => {\n      const z = mat4.multiply(out, camera.view, mesh.model)[14];\n      lookup.set(mesh, z);\n    });\n\n    meshes.sort((a, b) => lookup.get(a) - lookup.get(b));\n  };\n\n  let dimensions_need_update = true;\n\n  const update_dimensions = () => {\n    dimensions_need_update = true;\n    invalidate();\n  };\n\n  $: ($width, $height, update_dimensions());\n  $: (background, backgroundOpacity, fog, scene.invalidate());\n  $: if ($visible && pending) scene.invalidate();\n</script>\n\n<style>\n  .container, canvas {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    display: block;\n    overflow: hidden;\n  }\n</style>\n\n<div class=\"container\" bind:clientWidth={$width} bind:clientHeight={$height}>\n  <canvas bind:this={canvas}></canvas>\n\n  {#if gl}\n    <slot width={$width} height={$height}></slot>\n  {/if}\n</div>\n"
  ],
  "names": [],
  "mappings": "AAcE,MAAM,cAAC,CAAC,AACN,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,AACT,CAAC;ACED,QAAQ,eAAC,CAAC,AACR,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,CAAC,CACP,GAAG,CAAE,CAAC,CACN,WAAW,CAAE,IAAI,CACjB,gBAAgB,CAAE,IAAI,CACtB,WAAW,CAAE,SAAS,AACxB,CAAC;ACiYD,wBAAU,CAAE,MAAM,cAAC,CAAC,AAClB,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,OAAO,CAAE,KAAK,CACd,QAAQ,CAAE,MAAM,AAClB,CAAC"
}